from fastapi import APIRouter, UploadFile, Form, HTTPException, Depends
from fastapi.responses import JSONResponse
from utils.auth import verify_token
from domain.stability_profiles import STABILITY_PROFILES
from ingestion.csv_loader import load_temperature_csv, CSVSchemaError, CSVIngestionError
from services.forecast_service import run_forecast, ForecastModelViolation
from services.report_service import generate_investigation_report, ReportGenerationError
from persistence.investigation_repo import (
    create_investigation,
    save_temperature_readings,
    save_calculation,
)
from utils.ids import generate_investigation_id
from persistence.mongo import reports
from fastapi import APIRouter, Depends
from fastapi.responses import Response
from services.tts_service import synthesize_speech
from config import db
from .schema import TTSRequest
router = APIRouter()

@router.post("/api/forecast")
async def forecast(
    file: UploadFile,
    time_column:str | None = Form(None),
    temperature_column: str | None = Form(None),
    temperature_unit: str = Form("C"),
    stability_profile: str = Form(...),
    token_payload: dict = Depends(verify_token),
):
    user_sub = token_payload["sub"]

    # CSV ingestion
    file.file.seek(0)

    try:
        if file.filename.lower().endswith(".csv"):
            df = load_temperature_csv(
                file_obj=file.file,
                time_column=time_column,
                temperature_column=temperature_column,
                temperature_unit=temperature_unit,
            )
    except Exception as e:
        import traceback
        print("Document ingestion error:", str(e))
        traceback.print_exc()
        raise HTTPException(
            status_code=400,
            detail=f"Failed to extract data from document: {str(e)}"
        )


    df = df.sort_values("timestamp").reset_index(drop=True)
    timestamps = df["timestamp"].tolist()
    sensor_temps = df["air_temp"].tolist()

    # Forecast
    try:
        results, metrics = run_forecast(
            timestamps=timestamps,
            sensor_temps=sensor_temps,
            stability_profile_key=stability_profile,
        )
    except ForecastModelViolation as e:
        raise HTTPException(status_code=500, detail=str(e))
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

    # Persistence
    investigation_id = generate_investigation_id()
    create_investigation(investigation_id, user_sub)
    save_temperature_readings(investigation_id, timestamps, sensor_temps,user_sub)
    save_calculation(
        investigation_id=investigation_id,
        profile_key=stability_profile,
        Ea=metrics.get("Ea"),
        A=metrics.get("A"),
        alpha=0.1,
        metrics=metrics,
        user_sub=user_sub
    )

    return JSONResponse({"investigation_id": investigation_id, "results": results})


@router.get("/api/investigation_report/{investigation_id}")
async def investigation_report(
    investigation_id: str,
    token_payload: dict = Depends(verify_token),
):
    user_sub = token_payload["sub"]

    try:
        report = generate_investigation_report(investigation_id, user_sub)
    except ReportGenerationError as e:
        raise HTTPException(status_code=404, detail=str(e))

    return JSONResponse({"investigation_id": investigation_id, "report": report})


@router.get("/api/stability_profiles")
async def get_stability_profiles():
    return {
        "profiles": {
            k: {
                "storage_min": v["storage_min"],
                "storage_max": v["storage_max"],
            }
            for k, v in STABILITY_PROFILES.items()
        }
    }


@router.get("/api/reports")
async def get_reports_history(token_payload: dict = Depends(verify_token)):
    """
    Returns a list of all reports generated by the current user.
    """
    user_sub = token_payload["sub"]
    print("Token payload:", token_payload)
    print("User sub from token:", user_sub)

    user_reports = reports.find(
        {"user_sub": user_sub},
        {
            "_id": 0,
            "report_id": 1,
            "investigation_id": 1,
            "calculation_id": 1,
            "status": 1,
            "created_at": 1,
            "content": 1,
        },
    ).sort("created_at", -1)

    reports_list = []
    for r in user_reports:
        content = r.get("content", "")
        reports_list.append({
            "report_id": r["report_id"],
            "investigation_id": r["investigation_id"],
            "calculation_id": r.get("calculation_id"),
            "status": r.get("status", "UNKNOWN"),
            "created_at": r["created_at"].isoformat(),
            "content_preview": (
                content[:200] + "..." if len(content) > 200 else content
            ),
        })

    return {"reports": reports_list}


@router.post("/api/tts-report")
async def tts_report(payload: TTSRequest):
    print("[Route] Received TTS request for investigation_id:", payload.investigation_id)
    investigation_id = payload.investigation_id

    # Fetch report from DB
    report = db.reports.find_one(
        {"investigation_id": investigation_id},
        {"content": 1}
    )

    if not report or "content" not in report:
        print("[Route] Report not found for investigation_id:", investigation_id)
        raise HTTPException(
            status_code=404,
            detail="Report not found for investigation_id"
        )

    report_text = report["content"]
    print(f"[Route] Report found, content length: {len(report_text)}")

    try:
        audio_bytes = synthesize_speech(report_text)
        print("[Route] TTS audio bytes generated, length:", len(audio_bytes))
    except Exception as e:
        print("[Route] TTS generation failed:", str(e))
        raise

    return Response(
        content=audio_bytes,
        media_type="audio/wav",
        headers={"Content-Disposition": f"inline; filename={investigation_id}.wav"}
    )

@router.get("/api/get_report_content")
async def get_single_report(
    report_id: str, 
    investigation_id: str, 
    token_payload: dict = Depends(verify_token)
):
    """
    Returns the full content of a specific report after verifying ownership.
    """
    user_sub = token_payload["sub"]

    # Find the specific report belonging to this user
    report_data = reports.find_one(
        {
            "user_sub": user_sub,
            "report_id": report_id,
            "investigation_id": investigation_id
        },
        {"_id": 0, "content": 1}
    )

    if not report_data:
        raise HTTPException(status_code=404, detail="Report not found")

    return {"content": report_data.get("content", "")}